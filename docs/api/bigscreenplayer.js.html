<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>bigscreenplayer.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    <h2><a href="index.html">Home</a></h2><h3>Modules</h3><ul><li><a href="module-bigscreenplayer_bigscreenplayer.html">bigscreenplayer/bigscreenplayer</a><ul class='methods'><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.canPause">canPause</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.canSeek">canSeek</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.convertEpochMsToVideoTimeSeconds">convertEpochMsToVideoTimeSeconds</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.convertVideoTimeSecondsToEpochMs">convertVideoTimeSecondsToEpochMs</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getCurrentTime">getCurrentTime</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getDuration">getDuration</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getFrameworkVersion">getFrameworkVersion</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getLiveWindowData">getLiveWindowData</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getLogLevels">getLogLevels</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getMediaKind">getMediaKind</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getPlayerElement">getPlayerElement</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getSeekableRange">getSeekableRange</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.getWindowType">getWindowType</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.isEnded">isEnded</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.isPaused">isPaused</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.isPlayingAtLiveEdge">isPlayingAtLiveEdge</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.isSubtitlesAvailable">isSubtitlesAvailable</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.isSubtitlesEnabled">isSubtitlesEnabled</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.mock">mock</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.mockJasmine">mockJasmine</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.pause">pause</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.play">play</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.registerForStateChanges">registerForStateChanges</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.registerForSubtitleChanges">registerForSubtitleChanges</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.registerForTimeUpdates">registerForTimeUpdates</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.registerPlugin">registerPlugin</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.setCurrentTime">setCurrentTime</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.setLogLevel">setLogLevel</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.setSubtitlesEnabled">setSubtitlesEnabled</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.setTransportControlsPosition">setTransportControlsPosition</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.toggleDebug">toggleDebug</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.transitions">transitions</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.unmock">unmock</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.unregisterForStateChanges">unregisterForStateChanges</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.unregisterForSubtitleChanges">unregisterForSubtitleChanges</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.unregisterForTimeUpdates">unregisterForTimeUpdates</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#.unregisterPlugin">unregisterPlugin</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#~init">init</a></li><li data-type='method' style='display: none;'><a href="module-bigscreenplayer_bigscreenplayer.html#~tearDown">tearDown</a></li></ul></li><li><a href="module-bigscreenplayer_models_windowtypes.html">bigscreenplayer/models/windowtypes</a></li></ul><h3>Global</h3><ul><li><a href="global.html#Time">Time</a></li></ul>
</nav>

<div id="main">
    
    <h1 class="page-title">bigscreenplayer.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * @module bigscreenplayer/bigscreenplayer
 */
define('bigscreenplayer/bigscreenplayer',
  [
    'bigscreenplayer/models/mediastate',
    'bigscreenplayer/playercomponent',
    'bigscreenplayer/models/pausetriggers',
    'bigscreenplayer/dynamicwindowutils',
    'bigscreenplayer/models/windowtypes',
    'bigscreenplayer/mockbigscreenplayer',
    'bigscreenplayer/plugins',
    'bigscreenplayer/debugger/chronicle',
    'bigscreenplayer/debugger/debugtool',
    'bigscreenplayer/utils/timeutils',
    'bigscreenplayer/utils/callcallbacks',
    'bigscreenplayer/mediasources',
    'bigscreenplayer/version',
    'bigscreenplayer/resizer',
    'bigscreenplayer/readyhelper',
    'bigscreenplayer/subtitles/subtitles'
  ],
  function (MediaState, PlayerComponent, PauseTriggers, DynamicWindowUtils, WindowTypes, MockBigscreenPlayer, Plugins, Chronicle, DebugTool, SlidingWindowUtils, callCallbacks, MediaSources, Version, Resizer, ReadyHelper, Subtitles) {
    'use strict';
    function BigscreenPlayer () {
      var stateChangeCallbacks = [];
      var timeUpdateCallbacks = [];
      var subtitleCallbacks = [];
      var playerReadyCallback;
      var mediaKind;
      var initialPlaybackTimeEpoch;
      var serverDate;
      var playerComponent;
      var resizer;
      var pauseTrigger;
      var isSeeking = false;
      var endOfStream;
      var windowType;
      var mediaSources;
      var playbackElement;
      var readyHelper;
      var subtitles;

      var END_OF_STREAM_TOLERANCE = 10;

      function mediaStateUpdateCallback (evt) {
        if (evt.timeUpdate) {
          DebugTool.time(evt.data.currentTime);
          callCallbacks(timeUpdateCallbacks, {
            currentTime: evt.data.currentTime,
            endOfStream: endOfStream
          });
        } else {
          var stateObject = {state: evt.data.state};
          if (evt.data.state === MediaState.PAUSED) {
            endOfStream = false;
            stateObject.trigger = pauseTrigger || PauseTriggers.DEVICE;
            pauseTrigger = undefined;
          }

          if (evt.data.state === MediaState.FATAL_ERROR) {
            stateObject = {
              state: MediaState.FATAL_ERROR,
              isBufferingTimeoutError: evt.isBufferingTimeoutError
            };
          }

          if (evt.data.state === MediaState.WAITING) {
            stateObject.isSeeking = isSeeking;
            isSeeking = false;
          }

          stateObject.endOfStream = endOfStream;
          DebugTool.event(stateObject);

          callCallbacks(stateChangeCallbacks, stateObject);
        }

        if (evt.data.seekableRange) {
          DebugTool.keyValue({key: 'seekableRangeStart', value: deviceTimeToDate(evt.data.seekableRange.start)});
          DebugTool.keyValue({key: 'seekableRangeEnd', value: deviceTimeToDate(evt.data.seekableRange.end)});
        }

        if (evt.data.duration) {
          DebugTool.keyValue({key: 'duration', value: evt.data.duration});
        }

        if (playerComponent &amp;&amp; readyHelper) {
          readyHelper.callbackWhenReady(evt);
        }
      }

      function deviceTimeToDate (time) {
        if (getWindowStartTime()) {
          return new Date(convertVideoTimeSecondsToEpochMs(time));
        } else {
          return new Date(time * 1000);
        }
      }

      function convertVideoTimeSecondsToEpochMs (seconds) {
        return getWindowStartTime() ? getWindowStartTime() + (seconds * 1000) : undefined;
      }

      function bigscreenPlayerDataLoaded (bigscreenPlayerData, enableSubtitles) {
        if (windowType !== WindowTypes.STATIC) {
          bigscreenPlayerData.time = mediaSources.time();
          serverDate = bigscreenPlayerData.serverDate;

          initialPlaybackTimeEpoch = bigscreenPlayerData.initialPlaybackTime;
          // overwrite initialPlaybackTime with video time (it comes in as epoch time for a sliding/growing window)
          bigscreenPlayerData.initialPlaybackTime = SlidingWindowUtils.convertToSeekableVideoTime(bigscreenPlayerData.initialPlaybackTime, bigscreenPlayerData.time.windowStartTime);
        }

        mediaKind = bigscreenPlayerData.media.kind;
        endOfStream = windowType !== WindowTypes.STATIC &amp;&amp; (!bigscreenPlayerData.initialPlaybackTime &amp;&amp; bigscreenPlayerData.initialPlaybackTime !== 0);

        readyHelper = new ReadyHelper(
          bigscreenPlayerData.initialPlaybackTime,
          windowType,
          PlayerComponent.getLiveSupport(),
          playerReadyCallback
        );

        playerComponent = new PlayerComponent(
          playbackElement,
          bigscreenPlayerData,
          mediaSources,
          windowType,
          mediaStateUpdateCallback
        );

        subtitles = Subtitles(
          playerComponent,
          enableSubtitles,
          playbackElement,
          bigscreenPlayerData.media.subtitleCustomisation,
          mediaSources
        );

        if (enableSubtitles) {
          callSubtitlesCallbacks(true);
        }
      }

      function getWindowStartTime () {
        return mediaSources &amp;&amp; mediaSources.time().windowStartTime;
      }

      function getWindowEndTime () {
        return mediaSources &amp;&amp; mediaSources.time().windowEndTime;
      }

      function toggleDebug () {
        if (playerComponent) {
          DebugTool.toggleVisibility();
        }
      }

      function callSubtitlesCallbacks (enabled) {
        callCallbacks(subtitleCallbacks, { enabled: enabled });
      }

      function setSubtitlesEnabled (enabled) {
        enabled ? subtitles.enable() : subtitles.disable();
        callSubtitlesCallbacks(enabled);

        if (!resizer.isResized()) {
          enabled ? subtitles.show() : subtitles.hide();
        }
      }

      function isSubtitlesEnabled () {
        return subtitles ? subtitles.enabled() : false;
      }

      function isSubtitlesAvailable () {
        return subtitles ? subtitles.available() : false;
      }

      return /** @alias module:bigscreenplayer/bigscreenplayer */{
        /**
         * Data required for playback
         * @typedef {Object} BigscreenPlayerData
         * @property {Object} media
         * @property {String} media.type - source type e.g 'application/dash+xml'
         * @property {String} media.mimeType - mimeType e.g 'video/mp4'
         * @property {String} media.kind - 'video' or 'audio'
         * @property {String} media.captionsUrl - 'Location for a captions file'
         * @property {MediaUrl[]} media.urls - Media urls to use
         * @property {Date} serverDate - Date object with server time offset
         */

        /**
          * @typedef {Object} MediaUrl
          * @property {String} url - media endpoint
          * @property {String} cdn - identifier for the endpoint
          */

        /**
         *
         * @typedef {object} InitCallbacks
         * @property {function} [callbacks.onSuccess] - Called after Bigscreen Player is initialised
         * @property {function} [callbacks.onError] - Called when an error occurs during initialisation
         */

        /**
         * Call first to initialise bigscreen player for playback.
         * @function
         * @name init
         * @param {HTMLDivElement} playbackElement - The Div element where content elements should be rendered
         * @param {BigsceenPlayerData} bigscreenPlayerData
         * @param {WindowTypes} newWindowType - @see {@link module:bigscreenplayer/models/windowtypes}
         * @param {boolean} enableSubtitles - Enable subtitles on initialisation
         * @param {TALDevice} newDevice - An optional TAL device object
         * @param {InitCallbacks} callbacks
         */
        init: function (newPlaybackElement, bigscreenPlayerData, newWindowType, enableSubtitles, callbacks) {
          playbackElement = newPlaybackElement;
          Chronicle.init();
          resizer = Resizer();
          DebugTool.setRootElement(playbackElement);
          DebugTool.keyValue({key: 'framework-version', value: Version});
          windowType = newWindowType;
          serverDate = bigscreenPlayerData.serverDate;
          if (!callbacks) {
            callbacks = {};
          }
          playerReadyCallback = callbacks.onSuccess;

          var mediaSourceCallbacks = {
            onSuccess: function () {
              bigscreenPlayerDataLoaded(bigscreenPlayerData, enableSubtitles);
            },
            onError: function (error) {
              if (callbacks.onError) {
                callbacks.onError(error);
              }
            }
          };

          mediaSources = MediaSources();

          // Backwards compatibility with Old API; to be removed on Major Version Update
          if (bigscreenPlayerData.media &amp;&amp; !bigscreenPlayerData.media.captions &amp;&amp; bigscreenPlayerData.media.captionsUrl) {
            bigscreenPlayerData.media.captions = [{
              url: bigscreenPlayerData.media.captionsUrl
            }];
          }

          mediaSources.init(bigscreenPlayerData.media, serverDate, windowType, getLiveSupport(), mediaSourceCallbacks);
        },

        /**
         * Should be called at the end of all playback sessions. Resets state and clears any UI.
         * @function
         * @name tearDown
         */
        tearDown: function () {
          if (subtitles) {
            subtitles.tearDown();
            subtitles = undefined;
          }

          if (playerComponent) {
            playerComponent.tearDown();
            playerComponent = undefined;
          }

          if (mediaSources) {
            mediaSources.tearDown();
            mediaSources = undefined;
          }

          stateChangeCallbacks = [];
          timeUpdateCallbacks = [];
          subtitleCallbacks = [];
          endOfStream = undefined;
          mediaKind = undefined;
          pauseTrigger = undefined;
          windowType = undefined;
          resizer = undefined;
          this.unregisterPlugin();
          DebugTool.tearDown();
          Chronicle.tearDown();
        },

        /**
         * Pass a function to call whenever the player transitions state.
         * @see {@link module:models/mediastate}
         * @function
         * @param {Function} callback
         */
        registerForStateChanges: function (callback) {
          stateChangeCallbacks.push(callback);
          return callback;
        },

        /**
         * Unregisters a previously registered callback.
         * @function
         * @param {Function} callback
         */
        unregisterForStateChanges: function (callback) {
          var indexOf = stateChangeCallbacks.indexOf(callback);
          if (indexOf !== -1) {
            stateChangeCallbacks.splice(indexOf, 1);
          }
        },

        /**
         * Pass a function to call whenever the player issues a time update.
         * @function
         * @param {Function} callback
         */
        registerForTimeUpdates: function (callback) {
          timeUpdateCallbacks.push(callback);
          return callback;
        },

        /**
         * Unregisters a previously registered callback.
         * @function
         * @param {Function} callback
         */
        unregisterForTimeUpdates: function (callback) {
          var indexOf = timeUpdateCallbacks.indexOf(callback);

          if (indexOf !== -1) {
            timeUpdateCallbacks.splice(indexOf, 1);
          }
        },

        /**
         * Pass a function to be called whenever subtitles are enabled or disabled.
         * @function
         * @param {Function} callback
         */
        registerForSubtitleChanges: function (callback) {
          subtitleCallbacks.push(callback);
          return callback;
        },

        /**
         * Unregisters a previously registered callback for changes to subtitles.
         * @function
         * @param {Function} callback
         */
        unregisterForSubtitleChanges: function (callback) {
          var indexOf = subtitleCallbacks.indexOf(callback);
          if (indexOf !== -1) {
            subtitleCallbacks.splice(indexOf, 1);
          }
        },

        /**
         * Sets the current time of the media asset.
         * @function
         * @param {Number} time - In seconds
         */
        setCurrentTime: function (time) {
          DebugTool.apicall('setCurrentTime');
          if (playerComponent) {
            isSeeking = true; // this flag must be set before calling into playerComponent.setCurrentTime - as this synchronously fires a WAITING event (when native strategy).
            playerComponent.setCurrentTime(time);
            endOfStream = windowType !== WindowTypes.STATIC &amp;&amp; Math.abs(this.getSeekableRange().end - time) &lt; END_OF_STREAM_TOLERANCE;
          }
        },

        setPlaybackRate: function (rate) {
          if (playerComponent) {
            playerComponent.setPlaybackRate(rate);
          }
        },

        getPlaybackRate: function () {
          return playerComponent &amp;&amp; playerComponent.getPlaybackRate();
        },

        /**
         * Returns the media asset's current time in seconds.
         * @function
         */
        getCurrentTime: function () {
          return playerComponent &amp;&amp; playerComponent.getCurrentTime() || 0;
        },

        /**
         * Returns the current media kind.
         * 'audio' or 'video'
         * @function
         */
        getMediaKind: function () {
          return mediaKind;
        },

        /**
         * Returns the current window type.
         * @see {@link module:bigscreenplayer/models/windowtypes}
         * @function
         */
        getWindowType: function () {
          return windowType;
        },

        /**
         * Returns an object including the current start and end times.
         * @function
         * @returns {Object} {start: Number, end: Number}
         */
        getSeekableRange: function () {
          return playerComponent ? playerComponent.getSeekableRange() : {};
        },

        /**
        * @function
        * @returns {boolean} Returns true if media is initialised and playing a live stream within a tolerance of the end of the seekable range (10 seconds).
        */
        isPlayingAtLiveEdge: function () {
          return !!playerComponent &amp;&amp; windowType !== WindowTypes.STATIC &amp;&amp; Math.abs(this.getSeekableRange().end - this.getCurrentTime()) &lt; END_OF_STREAM_TOLERANCE;
        },

        /**
         * @function
         * @return {Object} An object of the shape {windowStartTime: Number, windowEndTime: Number, initialPlaybackTime: Number, serverDate: Date}
         */
        getLiveWindowData: function () {
          if (windowType === WindowTypes.STATIC) {
            return {};
          }

          return {
            windowStartTime: getWindowStartTime(),
            windowEndTime: getWindowEndTime(),
            initialPlaybackTime: initialPlaybackTimeEpoch,
            serverDate: serverDate
          };
        },

        /**
         * @function
         * @returns the duration of the media asset.
         */
        getDuration: function () {
          return playerComponent &amp;&amp; playerComponent.getDuration();
        },

        /**
         * @function
         * @returns if the player is paused.
         */
        isPaused: function () {
          return playerComponent ? playerComponent.isPaused() : true;
        },

        /**
         * @function
         * @returns if the media asset has ended.
         */
        isEnded: function () {
          return playerComponent ? playerComponent.isEnded() : false;
        },

        /**
         * Play the media assest from the current point in time.
         * @function
         */
        play: function () {
          DebugTool.apicall('play');
          playerComponent.play();
        },

        /**
         * Pause the media asset.
         * @function
         * @param {*} opts
         * @param {boolean} opts.userPause
         * @param {boolean} opts.disableAutoResume
         */
        pause: function (opts) {
          DebugTool.apicall('pause');
          pauseTrigger = opts &amp;&amp; opts.userPause === false ? PauseTriggers.APP : PauseTriggers.USER;
          playerComponent.pause(opts);
        },
        resize: function (top, left, width, height, zIndex) {
          subtitles.hide();
          resizer.resize(playbackElement, top, left, width, height, zIndex);
        },
        clearResize: function () {
          if (subtitles.enabled()) {
            subtitles.show();
          } else {
            subtitles.hide();
          }
          resizer.clear(playbackElement);
        },
        /**
         * Set whether or not subtitles should be enabled.
         * @function
         * @param {boolean} value
         */
        setSubtitlesEnabled: setSubtitlesEnabled,
        /**
         * @function
         * @return if subtitles are currently enabled.
         */
        isSubtitlesEnabled: isSubtitlesEnabled,
        /**
         * @function
         * @return Returns whether or not subtitles are currently enabled.
         */
        isSubtitlesAvailable: isSubtitlesAvailable,
        areSubtitlesCustomisable: function () {
          return !(window.bigscreenPlayer &amp;&amp; window.bigscreenPlayer.overrides &amp;&amp; window.bigscreenPlayer.overrides.legacySubtitles);
        },
        customiseSubtitles: function (styleOpts) {
          if (subtitles) {
            subtitles.customise(styleOpts);
          }
        },
        renderSubtitleExample: function (xmlString, styleOpts, safePosition) {
          if (subtitles) {
            subtitles.renderExample(xmlString, styleOpts, safePosition);
          }
        },
        clearSubtitleExample: function () {
          if (subtitles) {
            subtitles.clearExample();
          }
        },

        /**
         *
         * An enum may be used to set the on-screen position of any transport controls
         * (work in progress to remove this - UI concern).
         * @function
         * @param {*} position
         */
        setTransportControlsPosition: function (position) {
          if (subtitles) {
            subtitles.setPosition(position);
          }
        },

        /**
         * @function
         * @return Returns whether the current media asset is seekable.
         */
        canSeek: function () {
          return windowType === WindowTypes.STATIC || DynamicWindowUtils.canSeek(getWindowStartTime(), getWindowEndTime(), getLiveSupport(), this.getSeekableRange());
        },

        /**
         * @function
         * @return Returns whether the current media asset is pausable.
         */
        canPause: function () {
          return windowType === WindowTypes.STATIC || DynamicWindowUtils.canPause(getWindowStartTime(), getWindowEndTime(), getLiveSupport());
        },

        /**
         * Return a mock for in place testing.
         * @function
         * @param {*} opts
         */
        mock: function (opts) {
          MockBigscreenPlayer.mock(this, opts);
        },

        /**
         * Unmock the player.
         * @function
         */
        unmock: function () {
          MockBigscreenPlayer.unmock(this);
        },

        /**
         * Return a mock for unit tests.
         * @function
         * @param {*} opts
         */
        mockJasmine: function (opts) {
          MockBigscreenPlayer.mockJasmine(this, opts);
        },

        /**
         * Register a plugin for extended events.
         * @function
         * @param {*} plugin
         */
        registerPlugin: function (plugin) {
          Plugins.registerPlugin(plugin);
        },

        /**
         * Unregister a previously registered plugin.
         * @function
         * @param {*} plugin
         */
        unregisterPlugin: function (plugin) {
          Plugins.unregisterPlugin(plugin);
        },

        /**
         * Returns an object with a number of functions related to the ability to transition state
         * given the current state and the playback strategy in use.
         * @function
         */
        transitions: function () {
          return playerComponent ? playerComponent.transitions() : {};
        },

        /**
         * @function
         * @return The media element currently being used.
         */
        getPlayerElement: function () {
          return playerComponent &amp;&amp; playerComponent.getPlayerElement();
        },

        /**
         * @function
         * @param {Number} epochTime - Unix Epoch based time in milliseconds.
         * @return the time in seconds within the current sliding window.
         */
        convertEpochMsToVideoTimeSeconds: function (epochTime) {
          return getWindowStartTime() ? Math.floor((epochTime - getWindowStartTime()) / 1000) : undefined;
        },

        /**
         * @function
         * @return The runtime version of the library.
         */
        getFrameworkVersion: function () {
          return Version;
        },

        /**
         * @function
         * @param {Number} time - Seconds
         * @return the time in milliseconds within the current sliding window.
         */
        convertVideoTimeSecondsToEpochMs: convertVideoTimeSecondsToEpochMs,

        /**
         * Toggle the visibility of the debug tool overlay.
         * @function
         */
        toggleDebug: toggleDebug,

        /**
         * @function
         * @return {Object} - Key value pairs of available log levels
         */
        getLogLevels: function () {
          return DebugTool.logLevels;
        },

        /**
         * @function
         * @param logLevel -  log level to display @see getLogLevels
         */
        setLogLevel: DebugTool.setLogLevel
      };
    }

    /**
     * @function
     * @param {TALDevice} device
     * @return the live support of the device.
     */
    function getLiveSupport () {
      return PlayerComponent.getLiveSupport();
    }

    BigscreenPlayer.getLiveSupport = getLiveSupport;

    BigscreenPlayer.version = Version;

    return BigscreenPlayer;
  }
);
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> on Wed Jul 28 2021 10:59:42 GMT+0100 (British Summer Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>


<script src="scripts/collapse.js" defer></script>


</body>
</html>
